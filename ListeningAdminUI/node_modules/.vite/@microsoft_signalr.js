import {
  __require
} from "./chunk-IHTDASF6.js";

// node_modules/@microsoft/signalr/dist/esm/Errors.js
var __extends = function() {
  var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
    d.__proto__ = b;
  } || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var HttpError = function(_super) {
  __extends(HttpError2, _super);
  function HttpError2(errorMessage, statusCode) {
    var _newTarget = this.constructor;
    var _this = this;
    var trueProto = _newTarget.prototype;
    _this = _super.call(this, errorMessage) || this;
    _this.statusCode = statusCode;
    _this.__proto__ = trueProto;
    return _this;
  }
  return HttpError2;
}(Error);
var TimeoutError = function(_super) {
  __extends(TimeoutError2, _super);
  function TimeoutError2(errorMessage) {
    var _newTarget = this.constructor;
    if (errorMessage === void 0) {
      errorMessage = "A timeout occurred.";
    }
    var _this = this;
    var trueProto = _newTarget.prototype;
    _this = _super.call(this, errorMessage) || this;
    _this.__proto__ = trueProto;
    return _this;
  }
  return TimeoutError2;
}(Error);
var AbortError = function(_super) {
  __extends(AbortError2, _super);
  function AbortError2(errorMessage) {
    var _newTarget = this.constructor;
    if (errorMessage === void 0) {
      errorMessage = "An abort occurred.";
    }
    var _this = this;
    var trueProto = _newTarget.prototype;
    _this = _super.call(this, errorMessage) || this;
    _this.__proto__ = trueProto;
    return _this;
  }
  return AbortError2;
}(Error);

// node_modules/@microsoft/signalr/dist/esm/HttpClient.js
var __assign = Object.assign || function(t) {
  for (var s, i = 1, n = arguments.length; i < n; i++) {
    s = arguments[i];
    for (var p in s)
      if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
  }
  return t;
};
var HttpResponse = function() {
  function HttpResponse2(statusCode, statusText, content) {
    this.statusCode = statusCode;
    this.statusText = statusText;
    this.content = content;
  }
  return HttpResponse2;
}();
var HttpClient = function() {
  function HttpClient2() {
  }
  HttpClient2.prototype.get = function(url, options) {
    return this.send(__assign({}, options, { method: "GET", url }));
  };
  HttpClient2.prototype.post = function(url, options) {
    return this.send(__assign({}, options, { method: "POST", url }));
  };
  HttpClient2.prototype.delete = function(url, options) {
    return this.send(__assign({}, options, { method: "DELETE", url }));
  };
  HttpClient2.prototype.getCookieString = function(url) {
    return "";
  };
  return HttpClient2;
}();

// node_modules/@microsoft/signalr/dist/esm/ILogger.js
var LogLevel;
(function(LogLevel2) {
  LogLevel2[LogLevel2["Trace"] = 0] = "Trace";
  LogLevel2[LogLevel2["Debug"] = 1] = "Debug";
  LogLevel2[LogLevel2["Information"] = 2] = "Information";
  LogLevel2[LogLevel2["Warning"] = 3] = "Warning";
  LogLevel2[LogLevel2["Error"] = 4] = "Error";
  LogLevel2[LogLevel2["Critical"] = 5] = "Critical";
  LogLevel2[LogLevel2["None"] = 6] = "None";
})(LogLevel || (LogLevel = {}));

// node_modules/@microsoft/signalr/dist/esm/Loggers.js
var NullLogger = function() {
  function NullLogger2() {
  }
  NullLogger2.prototype.log = function(_logLevel, _message) {
  };
  NullLogger2.instance = new NullLogger2();
  return NullLogger2;
}();

// node_modules/@microsoft/signalr/dist/esm/Utils.js
var __assign2 = Object.assign || function(t) {
  for (var s, i = 1, n = arguments.length; i < n; i++) {
    s = arguments[i];
    for (var p in s)
      if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
  }
  return t;
};
var __awaiter = function(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : new P(function(resolve2) {
        resolve2(result.value);
      }).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var VERSION = "5.0.9";
var Arg = function() {
  function Arg2() {
  }
  Arg2.isRequired = function(val, name) {
    if (val === null || val === void 0) {
      throw new Error("The '" + name + "' argument is required.");
    }
  };
  Arg2.isNotEmpty = function(val, name) {
    if (!val || val.match(/^\s*$/)) {
      throw new Error("The '" + name + "' argument should not be empty.");
    }
  };
  Arg2.isIn = function(val, values, name) {
    if (!(val in values)) {
      throw new Error("Unknown " + name + " value: " + val + ".");
    }
  };
  return Arg2;
}();
var Platform = function() {
  function Platform2() {
  }
  Object.defineProperty(Platform2, "isBrowser", {
    get: function() {
      return typeof window === "object";
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(Platform2, "isWebWorker", {
    get: function() {
      return typeof self === "object" && "importScripts" in self;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(Platform2, "isNode", {
    get: function() {
      return !this.isBrowser && !this.isWebWorker;
    },
    enumerable: true,
    configurable: true
  });
  return Platform2;
}();
function getDataDetail(data, includeContent) {
  var detail = "";
  if (isArrayBuffer(data)) {
    detail = "Binary data of length " + data.byteLength;
    if (includeContent) {
      detail += ". Content: '" + formatArrayBuffer(data) + "'";
    }
  } else if (typeof data === "string") {
    detail = "String data of length " + data.length;
    if (includeContent) {
      detail += ". Content: '" + data + "'";
    }
  }
  return detail;
}
function formatArrayBuffer(data) {
  var view = new Uint8Array(data);
  var str = "";
  view.forEach(function(num) {
    var pad = num < 16 ? "0" : "";
    str += "0x" + pad + num.toString(16) + " ";
  });
  return str.substr(0, str.length - 1);
}
function isArrayBuffer(val) {
  return val && typeof ArrayBuffer !== "undefined" && (val instanceof ArrayBuffer || val.constructor && val.constructor.name === "ArrayBuffer");
}
function sendMessage(logger, transportName, httpClient, url, accessTokenFactory, content, logMessageContent, withCredentials, defaultHeaders) {
  return __awaiter(this, void 0, void 0, function() {
    var _a, headers, token, _b, name, value, responseType, response;
    return __generator(this, function(_c) {
      switch (_c.label) {
        case 0:
          headers = {};
          if (!accessTokenFactory)
            return [3, 2];
          return [4, accessTokenFactory()];
        case 1:
          token = _c.sent();
          if (token) {
            headers = (_a = {}, _a["Authorization"] = "Bearer " + token, _a);
          }
          _c.label = 2;
        case 2:
          _b = getUserAgentHeader(), name = _b[0], value = _b[1];
          headers[name] = value;
          logger.log(LogLevel.Trace, "(" + transportName + " transport) sending data. " + getDataDetail(content, logMessageContent) + ".");
          responseType = isArrayBuffer(content) ? "arraybuffer" : "text";
          return [4, httpClient.post(url, {
            content,
            headers: __assign2({}, headers, defaultHeaders),
            responseType,
            withCredentials
          })];
        case 3:
          response = _c.sent();
          logger.log(LogLevel.Trace, "(" + transportName + " transport) request complete. Response status: " + response.statusCode + ".");
          return [2];
      }
    });
  });
}
function createLogger(logger) {
  if (logger === void 0) {
    return new ConsoleLogger(LogLevel.Information);
  }
  if (logger === null) {
    return NullLogger.instance;
  }
  if (logger.log) {
    return logger;
  }
  return new ConsoleLogger(logger);
}
var SubjectSubscription = function() {
  function SubjectSubscription2(subject, observer) {
    this.subject = subject;
    this.observer = observer;
  }
  SubjectSubscription2.prototype.dispose = function() {
    var index = this.subject.observers.indexOf(this.observer);
    if (index > -1) {
      this.subject.observers.splice(index, 1);
    }
    if (this.subject.observers.length === 0 && this.subject.cancelCallback) {
      this.subject.cancelCallback().catch(function(_) {
      });
    }
  };
  return SubjectSubscription2;
}();
var ConsoleLogger = function() {
  function ConsoleLogger2(minimumLogLevel) {
    this.minimumLogLevel = minimumLogLevel;
    this.outputConsole = console;
  }
  ConsoleLogger2.prototype.log = function(logLevel, message) {
    if (logLevel >= this.minimumLogLevel) {
      switch (logLevel) {
        case LogLevel.Critical:
        case LogLevel.Error:
          this.outputConsole.error("[" + new Date().toISOString() + "] " + LogLevel[logLevel] + ": " + message);
          break;
        case LogLevel.Warning:
          this.outputConsole.warn("[" + new Date().toISOString() + "] " + LogLevel[logLevel] + ": " + message);
          break;
        case LogLevel.Information:
          this.outputConsole.info("[" + new Date().toISOString() + "] " + LogLevel[logLevel] + ": " + message);
          break;
        default:
          this.outputConsole.log("[" + new Date().toISOString() + "] " + LogLevel[logLevel] + ": " + message);
          break;
      }
    }
  };
  return ConsoleLogger2;
}();
function getUserAgentHeader() {
  var userAgentHeaderName = "X-SignalR-User-Agent";
  if (Platform.isNode) {
    userAgentHeaderName = "User-Agent";
  }
  return [userAgentHeaderName, constructUserAgent(VERSION, getOsName(), getRuntime(), getRuntimeVersion())];
}
function constructUserAgent(version, os, runtime, runtimeVersion) {
  var userAgent = "Microsoft SignalR/";
  var majorAndMinor = version.split(".");
  userAgent += majorAndMinor[0] + "." + majorAndMinor[1];
  userAgent += " (" + version + "; ";
  if (os && os !== "") {
    userAgent += os + "; ";
  } else {
    userAgent += "Unknown OS; ";
  }
  userAgent += "" + runtime;
  if (runtimeVersion) {
    userAgent += "; " + runtimeVersion;
  } else {
    userAgent += "; Unknown Runtime Version";
  }
  userAgent += ")";
  return userAgent;
}
function getOsName() {
  if (Platform.isNode) {
    switch (process.platform) {
      case "win32":
        return "Windows NT";
      case "darwin":
        return "macOS";
      case "linux":
        return "Linux";
      default:
        return process.platform;
    }
  } else {
    return "";
  }
}
function getRuntimeVersion() {
  if (Platform.isNode) {
    return process.versions.node;
  }
  return void 0;
}
function getRuntime() {
  if (Platform.isNode) {
    return "NodeJS";
  } else {
    return "Browser";
  }
}

// node_modules/@microsoft/signalr/dist/esm/FetchHttpClient.js
var __extends2 = function() {
  var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
    d.__proto__ = b;
  } || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign3 = Object.assign || function(t) {
  for (var s, i = 1, n = arguments.length; i < n; i++) {
    s = arguments[i];
    for (var p in s)
      if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
  }
  return t;
};
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : new P(function(resolve2) {
        resolve2(result.value);
      }).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator2 = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var FetchHttpClient = function(_super) {
  __extends2(FetchHttpClient2, _super);
  function FetchHttpClient2(logger) {
    var _this = _super.call(this) || this;
    _this.logger = logger;
    if (typeof fetch === "undefined") {
      var requireFunc = typeof __webpack_require__ === "function" ? __non_webpack_require__ : __require;
      _this.jar = new (requireFunc("tough-cookie")).CookieJar();
      _this.fetchType = requireFunc("node-fetch");
      _this.fetchType = requireFunc("fetch-cookie")(_this.fetchType, _this.jar);
      _this.abortControllerType = requireFunc("abort-controller");
    } else {
      _this.fetchType = fetch.bind(self);
      _this.abortControllerType = AbortController;
    }
    return _this;
  }
  FetchHttpClient2.prototype.send = function(request) {
    return __awaiter2(this, void 0, void 0, function() {
      var abortController, error, timeoutId, msTimeout, response, e_1, content, payload;
      var _this = this;
      return __generator2(this, function(_a) {
        switch (_a.label) {
          case 0:
            if (request.abortSignal && request.abortSignal.aborted) {
              throw new AbortError();
            }
            if (!request.method) {
              throw new Error("No method defined.");
            }
            if (!request.url) {
              throw new Error("No url defined.");
            }
            abortController = new this.abortControllerType();
            if (request.abortSignal) {
              request.abortSignal.onabort = function() {
                abortController.abort();
                error = new AbortError();
              };
            }
            timeoutId = null;
            if (request.timeout) {
              msTimeout = request.timeout;
              timeoutId = setTimeout(function() {
                abortController.abort();
                _this.logger.log(LogLevel.Warning, "Timeout from HTTP request.");
                error = new TimeoutError();
              }, msTimeout);
            }
            _a.label = 1;
          case 1:
            _a.trys.push([1, 3, 4, 5]);
            return [4, this.fetchType(request.url, {
              body: request.content,
              cache: "no-cache",
              credentials: request.withCredentials === true ? "include" : "same-origin",
              headers: __assign3({ "Content-Type": "text/plain;charset=UTF-8", "X-Requested-With": "XMLHttpRequest" }, request.headers),
              method: request.method,
              mode: "cors",
              redirect: "manual",
              signal: abortController.signal
            })];
          case 2:
            response = _a.sent();
            return [3, 5];
          case 3:
            e_1 = _a.sent();
            if (error) {
              throw error;
            }
            this.logger.log(LogLevel.Warning, "Error from HTTP request. " + e_1 + ".");
            throw e_1;
          case 4:
            if (timeoutId) {
              clearTimeout(timeoutId);
            }
            if (request.abortSignal) {
              request.abortSignal.onabort = null;
            }
            return [7];
          case 5:
            if (!response.ok) {
              throw new HttpError(response.statusText, response.status);
            }
            content = deserializeContent(response, request.responseType);
            return [4, content];
          case 6:
            payload = _a.sent();
            return [2, new HttpResponse(response.status, response.statusText, payload)];
        }
      });
    });
  };
  FetchHttpClient2.prototype.getCookieString = function(url) {
    var cookies = "";
    if (Platform.isNode && this.jar) {
      this.jar.getCookies(url, function(e, c) {
        return cookies = c.join("; ");
      });
    }
    return cookies;
  };
  return FetchHttpClient2;
}(HttpClient);
function deserializeContent(response, responseType) {
  var content;
  switch (responseType) {
    case "arraybuffer":
      content = response.arrayBuffer();
      break;
    case "text":
      content = response.text();
      break;
    case "blob":
    case "document":
    case "json":
      throw new Error(responseType + " is not supported.");
    default:
      content = response.text();
      break;
  }
  return content;
}

// node_modules/@microsoft/signalr/dist/esm/XhrHttpClient.js
var __extends3 = function() {
  var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
    d.__proto__ = b;
  } || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var XhrHttpClient = function(_super) {
  __extends3(XhrHttpClient2, _super);
  function XhrHttpClient2(logger) {
    var _this = _super.call(this) || this;
    _this.logger = logger;
    return _this;
  }
  XhrHttpClient2.prototype.send = function(request) {
    var _this = this;
    if (request.abortSignal && request.abortSignal.aborted) {
      return Promise.reject(new AbortError());
    }
    if (!request.method) {
      return Promise.reject(new Error("No method defined."));
    }
    if (!request.url) {
      return Promise.reject(new Error("No url defined."));
    }
    return new Promise(function(resolve, reject) {
      var xhr = new XMLHttpRequest();
      xhr.open(request.method, request.url, true);
      xhr.withCredentials = request.withCredentials === void 0 ? true : request.withCredentials;
      xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
      xhr.setRequestHeader("Content-Type", "text/plain;charset=UTF-8");
      var headers = request.headers;
      if (headers) {
        Object.keys(headers).forEach(function(header) {
          xhr.setRequestHeader(header, headers[header]);
        });
      }
      if (request.responseType) {
        xhr.responseType = request.responseType;
      }
      if (request.abortSignal) {
        request.abortSignal.onabort = function() {
          xhr.abort();
          reject(new AbortError());
        };
      }
      if (request.timeout) {
        xhr.timeout = request.timeout;
      }
      xhr.onload = function() {
        if (request.abortSignal) {
          request.abortSignal.onabort = null;
        }
        if (xhr.status >= 200 && xhr.status < 300) {
          resolve(new HttpResponse(xhr.status, xhr.statusText, xhr.response || xhr.responseText));
        } else {
          reject(new HttpError(xhr.statusText, xhr.status));
        }
      };
      xhr.onerror = function() {
        _this.logger.log(LogLevel.Warning, "Error from HTTP request. " + xhr.status + ": " + xhr.statusText + ".");
        reject(new HttpError(xhr.statusText, xhr.status));
      };
      xhr.ontimeout = function() {
        _this.logger.log(LogLevel.Warning, "Timeout from HTTP request.");
        reject(new TimeoutError());
      };
      xhr.send(request.content || "");
    });
  };
  return XhrHttpClient2;
}(HttpClient);

// node_modules/@microsoft/signalr/dist/esm/DefaultHttpClient.js
var __extends4 = function() {
  var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d, b) {
    d.__proto__ = b;
  } || function(d, b) {
    for (var p in b)
      if (b.hasOwnProperty(p))
        d[p] = b[p];
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var DefaultHttpClient = function(_super) {
  __extends4(DefaultHttpClient2, _super);
  function DefaultHttpClient2(logger) {
    var _this = _super.call(this) || this;
    if (typeof fetch !== "undefined" || Platform.isNode) {
      _this.httpClient = new FetchHttpClient(logger);
    } else if (typeof XMLHttpRequest !== "undefined") {
      _this.httpClient = new XhrHttpClient(logger);
    } else {
      throw new Error("No usable HttpClient found.");
    }
    return _this;
  }
  DefaultHttpClient2.prototype.send = function(request) {
    if (request.abortSignal && request.abortSignal.aborted) {
      return Promise.reject(new AbortError());
    }
    if (!request.method) {
      return Promise.reject(new Error("No method defined."));
    }
    if (!request.url) {
      return Promise.reject(new Error("No url defined."));
    }
    return this.httpClient.send(request);
  };
  DefaultHttpClient2.prototype.getCookieString = function(url) {
    return this.httpClient.getCookieString(url);
  };
  return DefaultHttpClient2;
}(HttpClient);

// node_modules/@microsoft/signalr/dist/esm/TextMessageFormat.js
var TextMessageFormat = function() {
  function TextMessageFormat2() {
  }
  TextMessageFormat2.write = function(output) {
    return "" + output + TextMessageFormat2.RecordSeparator;
  };
  TextMessageFormat2.parse = function(input) {
    if (input[input.length - 1] !== TextMessageFormat2.RecordSeparator) {
      throw new Error("Message is incomplete.");
    }
    var messages = input.split(TextMessageFormat2.RecordSeparator);
    messages.pop();
    return messages;
  };
  TextMessageFormat2.RecordSeparatorCode = 30;
  TextMessageFormat2.RecordSeparator = String.fromCharCode(TextMessageFormat2.RecordSeparatorCode);
  return TextMessageFormat2;
}();

// node_modules/@microsoft/signalr/dist/esm/HandshakeProtocol.js
var HandshakeProtocol = function() {
  function HandshakeProtocol2() {
  }
  HandshakeProtocol2.prototype.writeHandshakeRequest = function(handshakeRequest) {
    return TextMessageFormat.write(JSON.stringify(handshakeRequest));
  };
  HandshakeProtocol2.prototype.parseHandshakeResponse = function(data) {
    var responseMessage;
    var messageData;
    var remainingData;
    if (isArrayBuffer(data) || typeof Buffer !== "undefined" && data instanceof Buffer) {
      var binaryData = new Uint8Array(data);
      var separatorIndex = binaryData.indexOf(TextMessageFormat.RecordSeparatorCode);
      if (separatorIndex === -1) {
        throw new Error("Message is incomplete.");
      }
      var responseLength = separatorIndex + 1;
      messageData = String.fromCharCode.apply(null, binaryData.slice(0, responseLength));
      remainingData = binaryData.byteLength > responseLength ? binaryData.slice(responseLength).buffer : null;
    } else {
      var textData = data;
      var separatorIndex = textData.indexOf(TextMessageFormat.RecordSeparator);
      if (separatorIndex === -1) {
        throw new Error("Message is incomplete.");
      }
      var responseLength = separatorIndex + 1;
      messageData = textData.substring(0, responseLength);
      remainingData = textData.length > responseLength ? textData.substring(responseLength) : null;
    }
    var messages = TextMessageFormat.parse(messageData);
    var response = JSON.parse(messages[0]);
    if (response.type) {
      throw new Error("Expected a handshake response from the server.");
    }
    responseMessage = response;
    return [remainingData, responseMessage];
  };
  return HandshakeProtocol2;
}();

// node_modules/@microsoft/signalr/dist/esm/IHubProtocol.js
var MessageType;
(function(MessageType2) {
  MessageType2[MessageType2["Invocation"] = 1] = "Invocation";
  MessageType2[MessageType2["StreamItem"] = 2] = "StreamItem";
  MessageType2[MessageType2["Completion"] = 3] = "Completion";
  MessageType2[MessageType2["StreamInvocation"] = 4] = "StreamInvocation";
  MessageType2[MessageType2["CancelInvocation"] = 5] = "CancelInvocation";
  MessageType2[MessageType2["Ping"] = 6] = "Ping";
  MessageType2[MessageType2["Close"] = 7] = "Close";
})(MessageType || (MessageType = {}));

// node_modules/@microsoft/signalr/dist/esm/Subject.js
var Subject = function() {
  function Subject2() {
    this.observers = [];
  }
  Subject2.prototype.next = function(item) {
    for (var _i = 0, _a = this.observers; _i < _a.length; _i++) {
      var observer = _a[_i];
      observer.next(item);
    }
  };
  Subject2.prototype.error = function(err) {
    for (var _i = 0, _a = this.observers; _i < _a.length; _i++) {
      var observer = _a[_i];
      if (observer.error) {
        observer.error(err);
      }
    }
  };
  Subject2.prototype.complete = function() {
    for (var _i = 0, _a = this.observers; _i < _a.length; _i++) {
      var observer = _a[_i];
      if (observer.complete) {
        observer.complete();
      }
    }
  };
  Subject2.prototype.subscribe = function(observer) {
    this.observers.push(observer);
    return new SubjectSubscription(this, observer);
  };
  return Subject2;
}();

// node_modules/@microsoft/signalr/dist/esm/HubConnection.js
var __awaiter3 = function(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : new P(function(resolve2) {
        resolve2(result.value);
      }).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator3 = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var DEFAULT_TIMEOUT_IN_MS = 30 * 1e3;
var DEFAULT_PING_INTERVAL_IN_MS = 15 * 1e3;
var HubConnectionState;
(function(HubConnectionState2) {
  HubConnectionState2["Disconnected"] = "Disconnected";
  HubConnectionState2["Connecting"] = "Connecting";
  HubConnectionState2["Connected"] = "Connected";
  HubConnectionState2["Disconnecting"] = "Disconnecting";
  HubConnectionState2["Reconnecting"] = "Reconnecting";
})(HubConnectionState || (HubConnectionState = {}));
var HubConnection = function() {
  function HubConnection2(connection, logger, protocol, reconnectPolicy) {
    var _this = this;
    this.nextKeepAlive = 0;
    Arg.isRequired(connection, "connection");
    Arg.isRequired(logger, "logger");
    Arg.isRequired(protocol, "protocol");
    this.serverTimeoutInMilliseconds = DEFAULT_TIMEOUT_IN_MS;
    this.keepAliveIntervalInMilliseconds = DEFAULT_PING_INTERVAL_IN_MS;
    this.logger = logger;
    this.protocol = protocol;
    this.connection = connection;
    this.reconnectPolicy = reconnectPolicy;
    this.handshakeProtocol = new HandshakeProtocol();
    this.connection.onreceive = function(data) {
      return _this.processIncomingData(data);
    };
    this.connection.onclose = function(error) {
      return _this.connectionClosed(error);
    };
    this.callbacks = {};
    this.methods = {};
    this.closedCallbacks = [];
    this.reconnectingCallbacks = [];
    this.reconnectedCallbacks = [];
    this.invocationId = 0;
    this.receivedHandshakeResponse = false;
    this.connectionState = HubConnectionState.Disconnected;
    this.connectionStarted = false;
    this.cachedPingMessage = this.protocol.writeMessage({ type: MessageType.Ping });
  }
  HubConnection2.create = function(connection, logger, protocol, reconnectPolicy) {
    return new HubConnection2(connection, logger, protocol, reconnectPolicy);
  };
  Object.defineProperty(HubConnection2.prototype, "state", {
    get: function() {
      return this.connectionState;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(HubConnection2.prototype, "connectionId", {
    get: function() {
      return this.connection ? this.connection.connectionId || null : null;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(HubConnection2.prototype, "baseUrl", {
    get: function() {
      return this.connection.baseUrl || "";
    },
    set: function(url) {
      if (this.connectionState !== HubConnectionState.Disconnected && this.connectionState !== HubConnectionState.Reconnecting) {
        throw new Error("The HubConnection must be in the Disconnected or Reconnecting state to change the url.");
      }
      if (!url) {
        throw new Error("The HubConnection url must be a valid url.");
      }
      this.connection.baseUrl = url;
    },
    enumerable: true,
    configurable: true
  });
  HubConnection2.prototype.start = function() {
    this.startPromise = this.startWithStateTransitions();
    return this.startPromise;
  };
  HubConnection2.prototype.startWithStateTransitions = function() {
    return __awaiter3(this, void 0, void 0, function() {
      var e_1;
      return __generator3(this, function(_a) {
        switch (_a.label) {
          case 0:
            if (this.connectionState !== HubConnectionState.Disconnected) {
              return [2, Promise.reject(new Error("Cannot start a HubConnection that is not in the 'Disconnected' state."))];
            }
            this.connectionState = HubConnectionState.Connecting;
            this.logger.log(LogLevel.Debug, "Starting HubConnection.");
            _a.label = 1;
          case 1:
            _a.trys.push([1, 3, , 4]);
            return [4, this.startInternal()];
          case 2:
            _a.sent();
            this.connectionState = HubConnectionState.Connected;
            this.connectionStarted = true;
            this.logger.log(LogLevel.Debug, "HubConnection connected successfully.");
            return [3, 4];
          case 3:
            e_1 = _a.sent();
            this.connectionState = HubConnectionState.Disconnected;
            this.logger.log(LogLevel.Debug, "HubConnection failed to start successfully because of error '" + e_1 + "'.");
            return [2, Promise.reject(e_1)];
          case 4:
            return [2];
        }
      });
    });
  };
  HubConnection2.prototype.startInternal = function() {
    return __awaiter3(this, void 0, void 0, function() {
      var handshakePromise, handshakeRequest, e_2;
      var _this = this;
      return __generator3(this, function(_a) {
        switch (_a.label) {
          case 0:
            this.stopDuringStartError = void 0;
            this.receivedHandshakeResponse = false;
            handshakePromise = new Promise(function(resolve, reject) {
              _this.handshakeResolver = resolve;
              _this.handshakeRejecter = reject;
            });
            return [4, this.connection.start(this.protocol.transferFormat)];
          case 1:
            _a.sent();
            _a.label = 2;
          case 2:
            _a.trys.push([2, 5, , 7]);
            handshakeRequest = {
              protocol: this.protocol.name,
              version: this.protocol.version
            };
            this.logger.log(LogLevel.Debug, "Sending handshake request.");
            return [4, this.sendMessage(this.handshakeProtocol.writeHandshakeRequest(handshakeRequest))];
          case 3:
            _a.sent();
            this.logger.log(LogLevel.Information, "Using HubProtocol '" + this.protocol.name + "'.");
            this.cleanupTimeout();
            this.resetTimeoutPeriod();
            this.resetKeepAliveInterval();
            return [4, handshakePromise];
          case 4:
            _a.sent();
            if (this.stopDuringStartError) {
              throw this.stopDuringStartError;
            }
            return [3, 7];
          case 5:
            e_2 = _a.sent();
            this.logger.log(LogLevel.Debug, "Hub handshake failed with error '" + e_2 + "' during start(). Stopping HubConnection.");
            this.cleanupTimeout();
            this.cleanupPingTimer();
            return [4, this.connection.stop(e_2)];
          case 6:
            _a.sent();
            throw e_2;
          case 7:
            return [2];
        }
      });
    });
  };
  HubConnection2.prototype.stop = function() {
    return __awaiter3(this, void 0, void 0, function() {
      var startPromise, e_3;
      return __generator3(this, function(_a) {
        switch (_a.label) {
          case 0:
            startPromise = this.startPromise;
            this.stopPromise = this.stopInternal();
            return [4, this.stopPromise];
          case 1:
            _a.sent();
            _a.label = 2;
          case 2:
            _a.trys.push([2, 4, , 5]);
            return [4, startPromise];
          case 3:
            _a.sent();
            return [3, 5];
          case 4:
            e_3 = _a.sent();
            return [3, 5];
          case 5:
            return [2];
        }
      });
    });
  };
  HubConnection2.prototype.stopInternal = function(error) {
    if (this.connectionState === HubConnectionState.Disconnected) {
      this.logger.log(LogLevel.Debug, "Call to HubConnection.stop(" + error + ") ignored because it is already in the disconnected state.");
      return Promise.resolve();
    }
    if (this.connectionState === HubConnectionState.Disconnecting) {
      this.logger.log(LogLevel.Debug, "Call to HttpConnection.stop(" + error + ") ignored because the connection is already in the disconnecting state.");
      return this.stopPromise;
    }
    this.connectionState = HubConnectionState.Disconnecting;
    this.logger.log(LogLevel.Debug, "Stopping HubConnection.");
    if (this.reconnectDelayHandle) {
      this.logger.log(LogLevel.Debug, "Connection stopped during reconnect delay. Done reconnecting.");
      clearTimeout(this.reconnectDelayHandle);
      this.reconnectDelayHandle = void 0;
      this.completeClose();
      return Promise.resolve();
    }
    this.cleanupTimeout();
    this.cleanupPingTimer();
    this.stopDuringStartError = error || new Error("The connection was stopped before the hub handshake could complete.");
    return this.connection.stop(error);
  };
  HubConnection2.prototype.stream = function(methodName) {
    var _this = this;
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    var _a = this.replaceStreamingParams(args), streams = _a[0], streamIds = _a[1];
    var invocationDescriptor = this.createStreamInvocation(methodName, args, streamIds);
    var promiseQueue;
    var subject = new Subject();
    subject.cancelCallback = function() {
      var cancelInvocation = _this.createCancelInvocation(invocationDescriptor.invocationId);
      delete _this.callbacks[invocationDescriptor.invocationId];
      return promiseQueue.then(function() {
        return _this.sendWithProtocol(cancelInvocation);
      });
    };
    this.callbacks[invocationDescriptor.invocationId] = function(invocationEvent, error) {
      if (error) {
        subject.error(error);
        return;
      } else if (invocationEvent) {
        if (invocationEvent.type === MessageType.Completion) {
          if (invocationEvent.error) {
            subject.error(new Error(invocationEvent.error));
          } else {
            subject.complete();
          }
        } else {
          subject.next(invocationEvent.item);
        }
      }
    };
    promiseQueue = this.sendWithProtocol(invocationDescriptor).catch(function(e) {
      subject.error(e);
      delete _this.callbacks[invocationDescriptor.invocationId];
    });
    this.launchStreams(streams, promiseQueue);
    return subject;
  };
  HubConnection2.prototype.sendMessage = function(message) {
    this.resetKeepAliveInterval();
    return this.connection.send(message);
  };
  HubConnection2.prototype.sendWithProtocol = function(message) {
    return this.sendMessage(this.protocol.writeMessage(message));
  };
  HubConnection2.prototype.send = function(methodName) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    var _a = this.replaceStreamingParams(args), streams = _a[0], streamIds = _a[1];
    var sendPromise = this.sendWithProtocol(this.createInvocation(methodName, args, true, streamIds));
    this.launchStreams(streams, sendPromise);
    return sendPromise;
  };
  HubConnection2.prototype.invoke = function(methodName) {
    var _this = this;
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    var _a = this.replaceStreamingParams(args), streams = _a[0], streamIds = _a[1];
    var invocationDescriptor = this.createInvocation(methodName, args, false, streamIds);
    var p = new Promise(function(resolve, reject) {
      _this.callbacks[invocationDescriptor.invocationId] = function(invocationEvent, error) {
        if (error) {
          reject(error);
          return;
        } else if (invocationEvent) {
          if (invocationEvent.type === MessageType.Completion) {
            if (invocationEvent.error) {
              reject(new Error(invocationEvent.error));
            } else {
              resolve(invocationEvent.result);
            }
          } else {
            reject(new Error("Unexpected message type: " + invocationEvent.type));
          }
        }
      };
      var promiseQueue = _this.sendWithProtocol(invocationDescriptor).catch(function(e) {
        reject(e);
        delete _this.callbacks[invocationDescriptor.invocationId];
      });
      _this.launchStreams(streams, promiseQueue);
    });
    return p;
  };
  HubConnection2.prototype.on = function(methodName, newMethod) {
    if (!methodName || !newMethod) {
      return;
    }
    methodName = methodName.toLowerCase();
    if (!this.methods[methodName]) {
      this.methods[methodName] = [];
    }
    if (this.methods[methodName].indexOf(newMethod) !== -1) {
      return;
    }
    this.methods[methodName].push(newMethod);
  };
  HubConnection2.prototype.off = function(methodName, method) {
    if (!methodName) {
      return;
    }
    methodName = methodName.toLowerCase();
    var handlers = this.methods[methodName];
    if (!handlers) {
      return;
    }
    if (method) {
      var removeIdx = handlers.indexOf(method);
      if (removeIdx !== -1) {
        handlers.splice(removeIdx, 1);
        if (handlers.length === 0) {
          delete this.methods[methodName];
        }
      }
    } else {
      delete this.methods[methodName];
    }
  };
  HubConnection2.prototype.onclose = function(callback) {
    if (callback) {
      this.closedCallbacks.push(callback);
    }
  };
  HubConnection2.prototype.onreconnecting = function(callback) {
    if (callback) {
      this.reconnectingCallbacks.push(callback);
    }
  };
  HubConnection2.prototype.onreconnected = function(callback) {
    if (callback) {
      this.reconnectedCallbacks.push(callback);
    }
  };
  HubConnection2.prototype.processIncomingData = function(data) {
    this.cleanupTimeout();
    if (!this.receivedHandshakeResponse) {
      data = this.processHandshakeResponse(data);
      this.receivedHandshakeResponse = true;
    }
    if (data) {
      var messages = this.protocol.parseMessages(data, this.logger);
      for (var _i = 0, messages_1 = messages; _i < messages_1.length; _i++) {
        var message = messages_1[_i];
        switch (message.type) {
          case MessageType.Invocation:
            this.invokeClientMethod(message);
            break;
          case MessageType.StreamItem:
          case MessageType.Completion:
            var callback = this.callbacks[message.invocationId];
            if (callback) {
              if (message.type === MessageType.Completion) {
                delete this.callbacks[message.invocationId];
              }
              callback(message);
            }
            break;
          case MessageType.Ping:
            break;
          case MessageType.Close:
            this.logger.log(LogLevel.Information, "Close message received from server.");
            var error = message.error ? new Error("Server returned an error on close: " + message.error) : void 0;
            if (message.allowReconnect === true) {
              this.connection.stop(error);
            } else {
              this.stopPromise = this.stopInternal(error);
            }
            break;
          default:
            this.logger.log(LogLevel.Warning, "Invalid message type: " + message.type + ".");
            break;
        }
      }
    }
    this.resetTimeoutPeriod();
  };
  HubConnection2.prototype.processHandshakeResponse = function(data) {
    var _a;
    var responseMessage;
    var remainingData;
    try {
      _a = this.handshakeProtocol.parseHandshakeResponse(data), remainingData = _a[0], responseMessage = _a[1];
    } catch (e) {
      var message = "Error parsing handshake response: " + e;
      this.logger.log(LogLevel.Error, message);
      var error = new Error(message);
      this.handshakeRejecter(error);
      throw error;
    }
    if (responseMessage.error) {
      var message = "Server returned handshake error: " + responseMessage.error;
      this.logger.log(LogLevel.Error, message);
      var error = new Error(message);
      this.handshakeRejecter(error);
      throw error;
    } else {
      this.logger.log(LogLevel.Debug, "Server handshake complete.");
    }
    this.handshakeResolver();
    return remainingData;
  };
  HubConnection2.prototype.resetKeepAliveInterval = function() {
    if (this.connection.features.inherentKeepAlive) {
      return;
    }
    this.nextKeepAlive = new Date().getTime() + this.keepAliveIntervalInMilliseconds;
    this.cleanupPingTimer();
  };
  HubConnection2.prototype.resetTimeoutPeriod = function() {
    var _this = this;
    if (!this.connection.features || !this.connection.features.inherentKeepAlive) {
      this.timeoutHandle = setTimeout(function() {
        return _this.serverTimeout();
      }, this.serverTimeoutInMilliseconds);
      if (this.pingServerHandle === void 0) {
        var nextPing = this.nextKeepAlive - new Date().getTime();
        if (nextPing < 0) {
          nextPing = 0;
        }
        this.pingServerHandle = setTimeout(function() {
          return __awaiter3(_this, void 0, void 0, function() {
            var _a;
            return __generator3(this, function(_b) {
              switch (_b.label) {
                case 0:
                  if (!(this.connectionState === HubConnectionState.Connected))
                    return [3, 4];
                  _b.label = 1;
                case 1:
                  _b.trys.push([1, 3, , 4]);
                  return [4, this.sendMessage(this.cachedPingMessage)];
                case 2:
                  _b.sent();
                  return [3, 4];
                case 3:
                  _a = _b.sent();
                  this.cleanupPingTimer();
                  return [3, 4];
                case 4:
                  return [2];
              }
            });
          });
        }, nextPing);
      }
    }
  };
  HubConnection2.prototype.serverTimeout = function() {
    this.connection.stop(new Error("Server timeout elapsed without receiving a message from the server."));
  };
  HubConnection2.prototype.invokeClientMethod = function(invocationMessage) {
    var _this = this;
    var methods = this.methods[invocationMessage.target.toLowerCase()];
    if (methods) {
      try {
        methods.forEach(function(m) {
          return m.apply(_this, invocationMessage.arguments);
        });
      } catch (e) {
        this.logger.log(LogLevel.Error, "A callback for the method " + invocationMessage.target.toLowerCase() + " threw error '" + e + "'.");
      }
      if (invocationMessage.invocationId) {
        var message = "Server requested a response, which is not supported in this version of the client.";
        this.logger.log(LogLevel.Error, message);
        this.stopPromise = this.stopInternal(new Error(message));
      }
    } else {
      this.logger.log(LogLevel.Warning, "No client method with the name '" + invocationMessage.target + "' found.");
    }
  };
  HubConnection2.prototype.connectionClosed = function(error) {
    this.logger.log(LogLevel.Debug, "HubConnection.connectionClosed(" + error + ") called while in state " + this.connectionState + ".");
    this.stopDuringStartError = this.stopDuringStartError || error || new Error("The underlying connection was closed before the hub handshake could complete.");
    if (this.handshakeResolver) {
      this.handshakeResolver();
    }
    this.cancelCallbacksWithError(error || new Error("Invocation canceled due to the underlying connection being closed."));
    this.cleanupTimeout();
    this.cleanupPingTimer();
    if (this.connectionState === HubConnectionState.Disconnecting) {
      this.completeClose(error);
    } else if (this.connectionState === HubConnectionState.Connected && this.reconnectPolicy) {
      this.reconnect(error);
    } else if (this.connectionState === HubConnectionState.Connected) {
      this.completeClose(error);
    }
  };
  HubConnection2.prototype.completeClose = function(error) {
    var _this = this;
    if (this.connectionStarted) {
      this.connectionState = HubConnectionState.Disconnected;
      this.connectionStarted = false;
      try {
        this.closedCallbacks.forEach(function(c) {
          return c.apply(_this, [error]);
        });
      } catch (e) {
        this.logger.log(LogLevel.Error, "An onclose callback called with error '" + error + "' threw error '" + e + "'.");
      }
    }
  };
  HubConnection2.prototype.reconnect = function(error) {
    return __awaiter3(this, void 0, void 0, function() {
      var reconnectStartTime, previousReconnectAttempts, retryError, nextRetryDelay, e_4;
      var _this = this;
      return __generator3(this, function(_a) {
        switch (_a.label) {
          case 0:
            reconnectStartTime = Date.now();
            previousReconnectAttempts = 0;
            retryError = error !== void 0 ? error : new Error("Attempting to reconnect due to a unknown error.");
            nextRetryDelay = this.getNextRetryDelay(previousReconnectAttempts++, 0, retryError);
            if (nextRetryDelay === null) {
              this.logger.log(LogLevel.Debug, "Connection not reconnecting because the IRetryPolicy returned null on the first reconnect attempt.");
              this.completeClose(error);
              return [2];
            }
            this.connectionState = HubConnectionState.Reconnecting;
            if (error) {
              this.logger.log(LogLevel.Information, "Connection reconnecting because of error '" + error + "'.");
            } else {
              this.logger.log(LogLevel.Information, "Connection reconnecting.");
            }
            if (this.onreconnecting) {
              try {
                this.reconnectingCallbacks.forEach(function(c) {
                  return c.apply(_this, [error]);
                });
              } catch (e) {
                this.logger.log(LogLevel.Error, "An onreconnecting callback called with error '" + error + "' threw error '" + e + "'.");
              }
              if (this.connectionState !== HubConnectionState.Reconnecting) {
                this.logger.log(LogLevel.Debug, "Connection left the reconnecting state in onreconnecting callback. Done reconnecting.");
                return [2];
              }
            }
            _a.label = 1;
          case 1:
            if (!(nextRetryDelay !== null))
              return [3, 7];
            this.logger.log(LogLevel.Information, "Reconnect attempt number " + previousReconnectAttempts + " will start in " + nextRetryDelay + " ms.");
            return [4, new Promise(function(resolve) {
              _this.reconnectDelayHandle = setTimeout(resolve, nextRetryDelay);
            })];
          case 2:
            _a.sent();
            this.reconnectDelayHandle = void 0;
            if (this.connectionState !== HubConnectionState.Reconnecting) {
              this.logger.log(LogLevel.Debug, "Connection left the reconnecting state during reconnect delay. Done reconnecting.");
              return [2];
            }
            _a.label = 3;
          case 3:
            _a.trys.push([3, 5, , 6]);
            return [4, this.startInternal()];
          case 4:
            _a.sent();
            this.connectionState = HubConnectionState.Connected;
            this.logger.log(LogLevel.Information, "HubConnection reconnected successfully.");
            if (this.onreconnected) {
              try {
                this.reconnectedCallbacks.forEach(function(c) {
                  return c.apply(_this, [_this.connection.connectionId]);
                });
              } catch (e) {
                this.logger.log(LogLevel.Error, "An onreconnected callback called with connectionId '" + this.connection.connectionId + "; threw error '" + e + "'.");
              }
            }
            return [2];
          case 5:
            e_4 = _a.sent();
            this.logger.log(LogLevel.Information, "Reconnect attempt failed because of error '" + e_4 + "'.");
            if (this.connectionState !== HubConnectionState.Reconnecting) {
              this.logger.log(LogLevel.Debug, "Connection moved to the '" + this.connectionState + "' from the reconnecting state during reconnect attempt. Done reconnecting.");
              if (this.connectionState === HubConnectionState.Disconnecting) {
                this.completeClose();
              }
              return [2];
            }
            retryError = e_4 instanceof Error ? e_4 : new Error(e_4.toString());
            nextRetryDelay = this.getNextRetryDelay(previousReconnectAttempts++, Date.now() - reconnectStartTime, retryError);
            return [3, 6];
          case 6:
            return [3, 1];
          case 7:
            this.logger.log(LogLevel.Information, "Reconnect retries have been exhausted after " + (Date.now() - reconnectStartTime) + " ms and " + previousReconnectAttempts + " failed attempts. Connection disconnecting.");
            this.completeClose();
            return [2];
        }
      });
    });
  };
  HubConnection2.prototype.getNextRetryDelay = function(previousRetryCount, elapsedMilliseconds, retryReason) {
    try {
      return this.reconnectPolicy.nextRetryDelayInMilliseconds({
        elapsedMilliseconds,
        previousRetryCount,
        retryReason
      });
    } catch (e) {
      this.logger.log(LogLevel.Error, "IRetryPolicy.nextRetryDelayInMilliseconds(" + previousRetryCount + ", " + elapsedMilliseconds + ") threw error '" + e + "'.");
      return null;
    }
  };
  HubConnection2.prototype.cancelCallbacksWithError = function(error) {
    var callbacks = this.callbacks;
    this.callbacks = {};
    Object.keys(callbacks).forEach(function(key) {
      var callback = callbacks[key];
      callback(null, error);
    });
  };
  HubConnection2.prototype.cleanupPingTimer = function() {
    if (this.pingServerHandle) {
      clearTimeout(this.pingServerHandle);
      this.pingServerHandle = void 0;
    }
  };
  HubConnection2.prototype.cleanupTimeout = function() {
    if (this.timeoutHandle) {
      clearTimeout(this.timeoutHandle);
    }
  };
  HubConnection2.prototype.createInvocation = function(methodName, args, nonblocking, streamIds) {
    if (nonblocking) {
      if (streamIds.length !== 0) {
        return {
          arguments: args,
          streamIds,
          target: methodName,
          type: MessageType.Invocation
        };
      } else {
        return {
          arguments: args,
          target: methodName,
          type: MessageType.Invocation
        };
      }
    } else {
      var invocationId = this.invocationId;
      this.invocationId++;
      if (streamIds.length !== 0) {
        return {
          arguments: args,
          invocationId: invocationId.toString(),
          streamIds,
          target: methodName,
          type: MessageType.Invocation
        };
      } else {
        return {
          arguments: args,
          invocationId: invocationId.toString(),
          target: methodName,
          type: MessageType.Invocation
        };
      }
    }
  };
  HubConnection2.prototype.launchStreams = function(streams, promiseQueue) {
    var _this = this;
    if (streams.length === 0) {
      return;
    }
    if (!promiseQueue) {
      promiseQueue = Promise.resolve();
    }
    var _loop_1 = function(streamId2) {
      streams[streamId2].subscribe({
        complete: function() {
          promiseQueue = promiseQueue.then(function() {
            return _this.sendWithProtocol(_this.createCompletionMessage(streamId2));
          });
        },
        error: function(err) {
          var message;
          if (err instanceof Error) {
            message = err.message;
          } else if (err && err.toString) {
            message = err.toString();
          } else {
            message = "Unknown error";
          }
          promiseQueue = promiseQueue.then(function() {
            return _this.sendWithProtocol(_this.createCompletionMessage(streamId2, message));
          });
        },
        next: function(item) {
          promiseQueue = promiseQueue.then(function() {
            return _this.sendWithProtocol(_this.createStreamItemMessage(streamId2, item));
          });
        }
      });
    };
    for (var streamId in streams) {
      _loop_1(streamId);
    }
  };
  HubConnection2.prototype.replaceStreamingParams = function(args) {
    var streams = [];
    var streamIds = [];
    for (var i = 0; i < args.length; i++) {
      var argument = args[i];
      if (this.isObservable(argument)) {
        var streamId = this.invocationId;
        this.invocationId++;
        streams[streamId] = argument;
        streamIds.push(streamId.toString());
        args.splice(i, 1);
      }
    }
    return [streams, streamIds];
  };
  HubConnection2.prototype.isObservable = function(arg) {
    return arg && arg.subscribe && typeof arg.subscribe === "function";
  };
  HubConnection2.prototype.createStreamInvocation = function(methodName, args, streamIds) {
    var invocationId = this.invocationId;
    this.invocationId++;
    if (streamIds.length !== 0) {
      return {
        arguments: args,
        invocationId: invocationId.toString(),
        streamIds,
        target: methodName,
        type: MessageType.StreamInvocation
      };
    } else {
      return {
        arguments: args,
        invocationId: invocationId.toString(),
        target: methodName,
        type: MessageType.StreamInvocation
      };
    }
  };
  HubConnection2.prototype.createCancelInvocation = function(id) {
    return {
      invocationId: id,
      type: MessageType.CancelInvocation
    };
  };
  HubConnection2.prototype.createStreamItemMessage = function(id, item) {
    return {
      invocationId: id,
      item,
      type: MessageType.StreamItem
    };
  };
  HubConnection2.prototype.createCompletionMessage = function(id, error, result) {
    if (error) {
      return {
        error,
        invocationId: id,
        type: MessageType.Completion
      };
    }
    return {
      invocationId: id,
      result,
      type: MessageType.Completion
    };
  };
  return HubConnection2;
}();

// node_modules/@microsoft/signalr/dist/esm/DefaultReconnectPolicy.js
var DEFAULT_RETRY_DELAYS_IN_MILLISECONDS = [0, 2e3, 1e4, 3e4, null];
var DefaultReconnectPolicy = function() {
  function DefaultReconnectPolicy2(retryDelays) {
    this.retryDelays = retryDelays !== void 0 ? retryDelays.concat([null]) : DEFAULT_RETRY_DELAYS_IN_MILLISECONDS;
  }
  DefaultReconnectPolicy2.prototype.nextRetryDelayInMilliseconds = function(retryContext) {
    return this.retryDelays[retryContext.previousRetryCount];
  };
  return DefaultReconnectPolicy2;
}();

// node_modules/@microsoft/signalr/dist/esm/ITransport.js
var HttpTransportType;
(function(HttpTransportType2) {
  HttpTransportType2[HttpTransportType2["None"] = 0] = "None";
  HttpTransportType2[HttpTransportType2["WebSockets"] = 1] = "WebSockets";
  HttpTransportType2[HttpTransportType2["ServerSentEvents"] = 2] = "ServerSentEvents";
  HttpTransportType2[HttpTransportType2["LongPolling"] = 4] = "LongPolling";
})(HttpTransportType || (HttpTransportType = {}));
var TransferFormat;
(function(TransferFormat2) {
  TransferFormat2[TransferFormat2["Text"] = 1] = "Text";
  TransferFormat2[TransferFormat2["Binary"] = 2] = "Binary";
})(TransferFormat || (TransferFormat = {}));

// node_modules/@microsoft/signalr/dist/esm/AbortController.js
var AbortController2 = function() {
  function AbortController3() {
    this.isAborted = false;
    this.onabort = null;
  }
  AbortController3.prototype.abort = function() {
    if (!this.isAborted) {
      this.isAborted = true;
      if (this.onabort) {
        this.onabort();
      }
    }
  };
  Object.defineProperty(AbortController3.prototype, "signal", {
    get: function() {
      return this;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(AbortController3.prototype, "aborted", {
    get: function() {
      return this.isAborted;
    },
    enumerable: true,
    configurable: true
  });
  return AbortController3;
}();

// node_modules/@microsoft/signalr/dist/esm/LongPollingTransport.js
var __assign4 = Object.assign || function(t) {
  for (var s, i = 1, n = arguments.length; i < n; i++) {
    s = arguments[i];
    for (var p in s)
      if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
  }
  return t;
};
var __awaiter4 = function(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : new P(function(resolve2) {
        resolve2(result.value);
      }).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator4 = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var LongPollingTransport = function() {
  function LongPollingTransport2(httpClient, accessTokenFactory, logger, logMessageContent, withCredentials, headers) {
    this.httpClient = httpClient;
    this.accessTokenFactory = accessTokenFactory;
    this.logger = logger;
    this.pollAbort = new AbortController2();
    this.logMessageContent = logMessageContent;
    this.withCredentials = withCredentials;
    this.headers = headers;
    this.running = false;
    this.onreceive = null;
    this.onclose = null;
  }
  Object.defineProperty(LongPollingTransport2.prototype, "pollAborted", {
    get: function() {
      return this.pollAbort.aborted;
    },
    enumerable: true,
    configurable: true
  });
  LongPollingTransport2.prototype.connect = function(url, transferFormat) {
    return __awaiter4(this, void 0, void 0, function() {
      var _a, _b, name, value, headers, pollOptions, token, pollUrl, response;
      return __generator4(this, function(_c) {
        switch (_c.label) {
          case 0:
            Arg.isRequired(url, "url");
            Arg.isRequired(transferFormat, "transferFormat");
            Arg.isIn(transferFormat, TransferFormat, "transferFormat");
            this.url = url;
            this.logger.log(LogLevel.Trace, "(LongPolling transport) Connecting.");
            if (transferFormat === TransferFormat.Binary && (typeof XMLHttpRequest !== "undefined" && typeof new XMLHttpRequest().responseType !== "string")) {
              throw new Error("Binary protocols over XmlHttpRequest not implementing advanced features are not supported.");
            }
            _b = getUserAgentHeader(), name = _b[0], value = _b[1];
            headers = __assign4((_a = {}, _a[name] = value, _a), this.headers);
            pollOptions = {
              abortSignal: this.pollAbort.signal,
              headers,
              timeout: 1e5,
              withCredentials: this.withCredentials
            };
            if (transferFormat === TransferFormat.Binary) {
              pollOptions.responseType = "arraybuffer";
            }
            return [4, this.getAccessToken()];
          case 1:
            token = _c.sent();
            this.updateHeaderToken(pollOptions, token);
            pollUrl = url + "&_=" + Date.now();
            this.logger.log(LogLevel.Trace, "(LongPolling transport) polling: " + pollUrl + ".");
            return [4, this.httpClient.get(pollUrl, pollOptions)];
          case 2:
            response = _c.sent();
            if (response.statusCode !== 200) {
              this.logger.log(LogLevel.Error, "(LongPolling transport) Unexpected response code: " + response.statusCode + ".");
              this.closeError = new HttpError(response.statusText || "", response.statusCode);
              this.running = false;
            } else {
              this.running = true;
            }
            this.receiving = this.poll(this.url, pollOptions);
            return [2];
        }
      });
    });
  };
  LongPollingTransport2.prototype.getAccessToken = function() {
    return __awaiter4(this, void 0, void 0, function() {
      return __generator4(this, function(_a) {
        switch (_a.label) {
          case 0:
            if (!this.accessTokenFactory)
              return [3, 2];
            return [4, this.accessTokenFactory()];
          case 1:
            return [2, _a.sent()];
          case 2:
            return [2, null];
        }
      });
    });
  };
  LongPollingTransport2.prototype.updateHeaderToken = function(request, token) {
    if (!request.headers) {
      request.headers = {};
    }
    if (token) {
      request.headers["Authorization"] = "Bearer " + token;
      return;
    }
    if (request.headers["Authorization"]) {
      delete request.headers["Authorization"];
    }
  };
  LongPollingTransport2.prototype.poll = function(url, pollOptions) {
    return __awaiter4(this, void 0, void 0, function() {
      var token, pollUrl, response, e_1;
      return __generator4(this, function(_a) {
        switch (_a.label) {
          case 0:
            _a.trys.push([0, , 8, 9]);
            _a.label = 1;
          case 1:
            if (!this.running)
              return [3, 7];
            return [4, this.getAccessToken()];
          case 2:
            token = _a.sent();
            this.updateHeaderToken(pollOptions, token);
            _a.label = 3;
          case 3:
            _a.trys.push([3, 5, , 6]);
            pollUrl = url + "&_=" + Date.now();
            this.logger.log(LogLevel.Trace, "(LongPolling transport) polling: " + pollUrl + ".");
            return [4, this.httpClient.get(pollUrl, pollOptions)];
          case 4:
            response = _a.sent();
            if (response.statusCode === 204) {
              this.logger.log(LogLevel.Information, "(LongPolling transport) Poll terminated by server.");
              this.running = false;
            } else if (response.statusCode !== 200) {
              this.logger.log(LogLevel.Error, "(LongPolling transport) Unexpected response code: " + response.statusCode + ".");
              this.closeError = new HttpError(response.statusText || "", response.statusCode);
              this.running = false;
            } else {
              if (response.content) {
                this.logger.log(LogLevel.Trace, "(LongPolling transport) data received. " + getDataDetail(response.content, this.logMessageContent) + ".");
                if (this.onreceive) {
                  this.onreceive(response.content);
                }
              } else {
                this.logger.log(LogLevel.Trace, "(LongPolling transport) Poll timed out, reissuing.");
              }
            }
            return [3, 6];
          case 5:
            e_1 = _a.sent();
            if (!this.running) {
              this.logger.log(LogLevel.Trace, "(LongPolling transport) Poll errored after shutdown: " + e_1.message);
            } else {
              if (e_1 instanceof TimeoutError) {
                this.logger.log(LogLevel.Trace, "(LongPolling transport) Poll timed out, reissuing.");
              } else {
                this.closeError = e_1;
                this.running = false;
              }
            }
            return [3, 6];
          case 6:
            return [3, 1];
          case 7:
            return [3, 9];
          case 8:
            this.logger.log(LogLevel.Trace, "(LongPolling transport) Polling complete.");
            if (!this.pollAborted) {
              this.raiseOnClose();
            }
            return [7];
          case 9:
            return [2];
        }
      });
    });
  };
  LongPollingTransport2.prototype.send = function(data) {
    return __awaiter4(this, void 0, void 0, function() {
      return __generator4(this, function(_a) {
        if (!this.running) {
          return [2, Promise.reject(new Error("Cannot send until the transport is connected"))];
        }
        return [2, sendMessage(this.logger, "LongPolling", this.httpClient, this.url, this.accessTokenFactory, data, this.logMessageContent, this.withCredentials, this.headers)];
      });
    });
  };
  LongPollingTransport2.prototype.stop = function() {
    return __awaiter4(this, void 0, void 0, function() {
      var headers, _a, name_1, value, deleteOptions, token;
      return __generator4(this, function(_b) {
        switch (_b.label) {
          case 0:
            this.logger.log(LogLevel.Trace, "(LongPolling transport) Stopping polling.");
            this.running = false;
            this.pollAbort.abort();
            _b.label = 1;
          case 1:
            _b.trys.push([1, , 5, 6]);
            return [4, this.receiving];
          case 2:
            _b.sent();
            this.logger.log(LogLevel.Trace, "(LongPolling transport) sending DELETE request to " + this.url + ".");
            headers = {};
            _a = getUserAgentHeader(), name_1 = _a[0], value = _a[1];
            headers[name_1] = value;
            deleteOptions = {
              headers: __assign4({}, headers, this.headers),
              withCredentials: this.withCredentials
            };
            return [4, this.getAccessToken()];
          case 3:
            token = _b.sent();
            this.updateHeaderToken(deleteOptions, token);
            return [4, this.httpClient.delete(this.url, deleteOptions)];
          case 4:
            _b.sent();
            this.logger.log(LogLevel.Trace, "(LongPolling transport) DELETE request sent.");
            return [3, 6];
          case 5:
            this.logger.log(LogLevel.Trace, "(LongPolling transport) Stop finished.");
            this.raiseOnClose();
            return [7];
          case 6:
            return [2];
        }
      });
    });
  };
  LongPollingTransport2.prototype.raiseOnClose = function() {
    if (this.onclose) {
      var logMessage = "(LongPolling transport) Firing onclose event.";
      if (this.closeError) {
        logMessage += " Error: " + this.closeError;
      }
      this.logger.log(LogLevel.Trace, logMessage);
      this.onclose(this.closeError);
    }
  };
  return LongPollingTransport2;
}();

// node_modules/@microsoft/signalr/dist/esm/ServerSentEventsTransport.js
var __assign5 = Object.assign || function(t) {
  for (var s, i = 1, n = arguments.length; i < n; i++) {
    s = arguments[i];
    for (var p in s)
      if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
  }
  return t;
};
var __awaiter5 = function(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : new P(function(resolve2) {
        resolve2(result.value);
      }).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator5 = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var ServerSentEventsTransport = function() {
  function ServerSentEventsTransport2(httpClient, accessTokenFactory, logger, logMessageContent, eventSourceConstructor, withCredentials, headers) {
    this.httpClient = httpClient;
    this.accessTokenFactory = accessTokenFactory;
    this.logger = logger;
    this.logMessageContent = logMessageContent;
    this.withCredentials = withCredentials;
    this.eventSourceConstructor = eventSourceConstructor;
    this.headers = headers;
    this.onreceive = null;
    this.onclose = null;
  }
  ServerSentEventsTransport2.prototype.connect = function(url, transferFormat) {
    return __awaiter5(this, void 0, void 0, function() {
      var token;
      var _this = this;
      return __generator5(this, function(_a) {
        switch (_a.label) {
          case 0:
            Arg.isRequired(url, "url");
            Arg.isRequired(transferFormat, "transferFormat");
            Arg.isIn(transferFormat, TransferFormat, "transferFormat");
            this.logger.log(LogLevel.Trace, "(SSE transport) Connecting.");
            this.url = url;
            if (!this.accessTokenFactory)
              return [3, 2];
            return [4, this.accessTokenFactory()];
          case 1:
            token = _a.sent();
            if (token) {
              url += (url.indexOf("?") < 0 ? "?" : "&") + ("access_token=" + encodeURIComponent(token));
            }
            _a.label = 2;
          case 2:
            return [2, new Promise(function(resolve, reject) {
              var opened = false;
              if (transferFormat !== TransferFormat.Text) {
                reject(new Error("The Server-Sent Events transport only supports the 'Text' transfer format"));
                return;
              }
              var eventSource;
              if (Platform.isBrowser || Platform.isWebWorker) {
                eventSource = new _this.eventSourceConstructor(url, { withCredentials: _this.withCredentials });
              } else {
                var cookies = _this.httpClient.getCookieString(url);
                var headers = {};
                headers.Cookie = cookies;
                var _a2 = getUserAgentHeader(), name_1 = _a2[0], value = _a2[1];
                headers[name_1] = value;
                eventSource = new _this.eventSourceConstructor(url, { withCredentials: _this.withCredentials, headers: __assign5({}, headers, _this.headers) });
              }
              try {
                eventSource.onmessage = function(e) {
                  if (_this.onreceive) {
                    try {
                      _this.logger.log(LogLevel.Trace, "(SSE transport) data received. " + getDataDetail(e.data, _this.logMessageContent) + ".");
                      _this.onreceive(e.data);
                    } catch (error) {
                      _this.close(error);
                      return;
                    }
                  }
                };
                eventSource.onerror = function(e) {
                  var error = new Error(e.data || "Error occurred");
                  if (opened) {
                    _this.close(error);
                  } else {
                    reject(error);
                  }
                };
                eventSource.onopen = function() {
                  _this.logger.log(LogLevel.Information, "SSE connected to " + _this.url);
                  _this.eventSource = eventSource;
                  opened = true;
                  resolve();
                };
              } catch (e) {
                reject(e);
                return;
              }
            })];
        }
      });
    });
  };
  ServerSentEventsTransport2.prototype.send = function(data) {
    return __awaiter5(this, void 0, void 0, function() {
      return __generator5(this, function(_a) {
        if (!this.eventSource) {
          return [2, Promise.reject(new Error("Cannot send until the transport is connected"))];
        }
        return [2, sendMessage(this.logger, "SSE", this.httpClient, this.url, this.accessTokenFactory, data, this.logMessageContent, this.withCredentials, this.headers)];
      });
    });
  };
  ServerSentEventsTransport2.prototype.stop = function() {
    this.close();
    return Promise.resolve();
  };
  ServerSentEventsTransport2.prototype.close = function(e) {
    if (this.eventSource) {
      this.eventSource.close();
      this.eventSource = void 0;
      if (this.onclose) {
        this.onclose(e);
      }
    }
  };
  return ServerSentEventsTransport2;
}();

// node_modules/@microsoft/signalr/dist/esm/WebSocketTransport.js
var __assign6 = Object.assign || function(t) {
  for (var s, i = 1, n = arguments.length; i < n; i++) {
    s = arguments[i];
    for (var p in s)
      if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
  }
  return t;
};
var __awaiter6 = function(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : new P(function(resolve2) {
        resolve2(result.value);
      }).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator6 = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var WebSocketTransport = function() {
  function WebSocketTransport2(httpClient, accessTokenFactory, logger, logMessageContent, webSocketConstructor, headers) {
    this.logger = logger;
    this.accessTokenFactory = accessTokenFactory;
    this.logMessageContent = logMessageContent;
    this.webSocketConstructor = webSocketConstructor;
    this.httpClient = httpClient;
    this.onreceive = null;
    this.onclose = null;
    this.headers = headers;
  }
  WebSocketTransport2.prototype.connect = function(url, transferFormat) {
    return __awaiter6(this, void 0, void 0, function() {
      var token;
      var _this = this;
      return __generator6(this, function(_a) {
        switch (_a.label) {
          case 0:
            Arg.isRequired(url, "url");
            Arg.isRequired(transferFormat, "transferFormat");
            Arg.isIn(transferFormat, TransferFormat, "transferFormat");
            this.logger.log(LogLevel.Trace, "(WebSockets transport) Connecting.");
            if (!this.accessTokenFactory)
              return [3, 2];
            return [4, this.accessTokenFactory()];
          case 1:
            token = _a.sent();
            if (token) {
              url += (url.indexOf("?") < 0 ? "?" : "&") + ("access_token=" + encodeURIComponent(token));
            }
            _a.label = 2;
          case 2:
            return [2, new Promise(function(resolve, reject) {
              url = url.replace(/^http/, "ws");
              var webSocket;
              var cookies = _this.httpClient.getCookieString(url);
              var opened = false;
              if (Platform.isNode) {
                var headers = {};
                var _a2 = getUserAgentHeader(), name_1 = _a2[0], value = _a2[1];
                headers[name_1] = value;
                if (cookies) {
                  headers["Cookie"] = "" + cookies;
                }
                webSocket = new _this.webSocketConstructor(url, void 0, {
                  headers: __assign6({}, headers, _this.headers)
                });
              }
              if (!webSocket) {
                webSocket = new _this.webSocketConstructor(url);
              }
              if (transferFormat === TransferFormat.Binary) {
                webSocket.binaryType = "arraybuffer";
              }
              webSocket.onopen = function(_event) {
                _this.logger.log(LogLevel.Information, "WebSocket connected to " + url + ".");
                _this.webSocket = webSocket;
                opened = true;
                resolve();
              };
              webSocket.onerror = function(event) {
                var error = null;
                if (typeof ErrorEvent !== "undefined" && event instanceof ErrorEvent) {
                  error = event.error;
                } else {
                  error = new Error("There was an error with the transport.");
                }
                reject(error);
              };
              webSocket.onmessage = function(message) {
                _this.logger.log(LogLevel.Trace, "(WebSockets transport) data received. " + getDataDetail(message.data, _this.logMessageContent) + ".");
                if (_this.onreceive) {
                  try {
                    _this.onreceive(message.data);
                  } catch (error) {
                    _this.close(error);
                    return;
                  }
                }
              };
              webSocket.onclose = function(event) {
                if (opened) {
                  _this.close(event);
                } else {
                  var error = null;
                  if (typeof ErrorEvent !== "undefined" && event instanceof ErrorEvent) {
                    error = event.error;
                  } else {
                    error = new Error("There was an error with the transport.");
                  }
                  reject(error);
                }
              };
            })];
        }
      });
    });
  };
  WebSocketTransport2.prototype.send = function(data) {
    if (this.webSocket && this.webSocket.readyState === this.webSocketConstructor.OPEN) {
      this.logger.log(LogLevel.Trace, "(WebSockets transport) sending data. " + getDataDetail(data, this.logMessageContent) + ".");
      this.webSocket.send(data);
      return Promise.resolve();
    }
    return Promise.reject("WebSocket is not in the OPEN state");
  };
  WebSocketTransport2.prototype.stop = function() {
    if (this.webSocket) {
      this.close(void 0);
    }
    return Promise.resolve();
  };
  WebSocketTransport2.prototype.close = function(event) {
    if (this.webSocket) {
      this.webSocket.onclose = function() {
      };
      this.webSocket.onmessage = function() {
      };
      this.webSocket.onerror = function() {
      };
      this.webSocket.close();
      this.webSocket = void 0;
    }
    this.logger.log(LogLevel.Trace, "(WebSockets transport) socket closed.");
    if (this.onclose) {
      if (this.isCloseEvent(event) && (event.wasClean === false || event.code !== 1e3)) {
        this.onclose(new Error("WebSocket closed with status code: " + event.code + " (" + event.reason + ")."));
      } else if (event instanceof Error) {
        this.onclose(event);
      } else {
        this.onclose();
      }
    }
  };
  WebSocketTransport2.prototype.isCloseEvent = function(event) {
    return event && typeof event.wasClean === "boolean" && typeof event.code === "number";
  };
  return WebSocketTransport2;
}();

// node_modules/@microsoft/signalr/dist/esm/HttpConnection.js
var __assign7 = Object.assign || function(t) {
  for (var s, i = 1, n = arguments.length; i < n; i++) {
    s = arguments[i];
    for (var p in s)
      if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
  }
  return t;
};
var __awaiter7 = function(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : new P(function(resolve2) {
        resolve2(result.value);
      }).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator7 = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var MAX_REDIRECTS = 100;
var HttpConnection = function() {
  function HttpConnection2(url, options) {
    if (options === void 0) {
      options = {};
    }
    this.stopPromiseResolver = function() {
    };
    this.features = {};
    this.negotiateVersion = 1;
    Arg.isRequired(url, "url");
    this.logger = createLogger(options.logger);
    this.baseUrl = this.resolveUrl(url);
    options = options || {};
    options.logMessageContent = options.logMessageContent === void 0 ? false : options.logMessageContent;
    if (typeof options.withCredentials === "boolean" || options.withCredentials === void 0) {
      options.withCredentials = options.withCredentials === void 0 ? true : options.withCredentials;
    } else {
      throw new Error("withCredentials option was not a 'boolean' or 'undefined' value");
    }
    var webSocketModule = null;
    var eventSourceModule = null;
    if (Platform.isNode && typeof __require !== "undefined") {
      var requireFunc = typeof __webpack_require__ === "function" ? __non_webpack_require__ : __require;
      webSocketModule = requireFunc("ws");
      eventSourceModule = requireFunc("eventsource");
    }
    if (!Platform.isNode && typeof WebSocket !== "undefined" && !options.WebSocket) {
      options.WebSocket = WebSocket;
    } else if (Platform.isNode && !options.WebSocket) {
      if (webSocketModule) {
        options.WebSocket = webSocketModule;
      }
    }
    if (!Platform.isNode && typeof EventSource !== "undefined" && !options.EventSource) {
      options.EventSource = EventSource;
    } else if (Platform.isNode && !options.EventSource) {
      if (typeof eventSourceModule !== "undefined") {
        options.EventSource = eventSourceModule;
      }
    }
    this.httpClient = options.httpClient || new DefaultHttpClient(this.logger);
    this.connectionState = "Disconnected";
    this.connectionStarted = false;
    this.options = options;
    this.onreceive = null;
    this.onclose = null;
  }
  HttpConnection2.prototype.start = function(transferFormat) {
    return __awaiter7(this, void 0, void 0, function() {
      var message, message;
      return __generator7(this, function(_a) {
        switch (_a.label) {
          case 0:
            transferFormat = transferFormat || TransferFormat.Binary;
            Arg.isIn(transferFormat, TransferFormat, "transferFormat");
            this.logger.log(LogLevel.Debug, "Starting connection with transfer format '" + TransferFormat[transferFormat] + "'.");
            if (this.connectionState !== "Disconnected") {
              return [2, Promise.reject(new Error("Cannot start an HttpConnection that is not in the 'Disconnected' state."))];
            }
            this.connectionState = "Connecting";
            this.startInternalPromise = this.startInternal(transferFormat);
            return [4, this.startInternalPromise];
          case 1:
            _a.sent();
            if (!(this.connectionState === "Disconnecting"))
              return [3, 3];
            message = "Failed to start the HttpConnection before stop() was called.";
            this.logger.log(LogLevel.Error, message);
            return [4, this.stopPromise];
          case 2:
            _a.sent();
            return [2, Promise.reject(new Error(message))];
          case 3:
            if (this.connectionState !== "Connected") {
              message = "HttpConnection.startInternal completed gracefully but didn't enter the connection into the connected state!";
              this.logger.log(LogLevel.Error, message);
              return [2, Promise.reject(new Error(message))];
            }
            _a.label = 4;
          case 4:
            this.connectionStarted = true;
            return [2];
        }
      });
    });
  };
  HttpConnection2.prototype.send = function(data) {
    if (this.connectionState !== "Connected") {
      return Promise.reject(new Error("Cannot send data if the connection is not in the 'Connected' State."));
    }
    if (!this.sendQueue) {
      this.sendQueue = new TransportSendQueue(this.transport);
    }
    return this.sendQueue.send(data);
  };
  HttpConnection2.prototype.stop = function(error) {
    return __awaiter7(this, void 0, void 0, function() {
      var _this = this;
      return __generator7(this, function(_a) {
        switch (_a.label) {
          case 0:
            if (this.connectionState === "Disconnected") {
              this.logger.log(LogLevel.Debug, "Call to HttpConnection.stop(" + error + ") ignored because the connection is already in the disconnected state.");
              return [2, Promise.resolve()];
            }
            if (this.connectionState === "Disconnecting") {
              this.logger.log(LogLevel.Debug, "Call to HttpConnection.stop(" + error + ") ignored because the connection is already in the disconnecting state.");
              return [2, this.stopPromise];
            }
            this.connectionState = "Disconnecting";
            this.stopPromise = new Promise(function(resolve) {
              _this.stopPromiseResolver = resolve;
            });
            return [4, this.stopInternal(error)];
          case 1:
            _a.sent();
            return [4, this.stopPromise];
          case 2:
            _a.sent();
            return [2];
        }
      });
    });
  };
  HttpConnection2.prototype.stopInternal = function(error) {
    return __awaiter7(this, void 0, void 0, function() {
      var e_1, e_2;
      return __generator7(this, function(_a) {
        switch (_a.label) {
          case 0:
            this.stopError = error;
            _a.label = 1;
          case 1:
            _a.trys.push([1, 3, , 4]);
            return [4, this.startInternalPromise];
          case 2:
            _a.sent();
            return [3, 4];
          case 3:
            e_1 = _a.sent();
            return [3, 4];
          case 4:
            if (!this.transport)
              return [3, 9];
            _a.label = 5;
          case 5:
            _a.trys.push([5, 7, , 8]);
            return [4, this.transport.stop()];
          case 6:
            _a.sent();
            return [3, 8];
          case 7:
            e_2 = _a.sent();
            this.logger.log(LogLevel.Error, "HttpConnection.transport.stop() threw error '" + e_2 + "'.");
            this.stopConnection();
            return [3, 8];
          case 8:
            this.transport = void 0;
            return [3, 10];
          case 9:
            this.logger.log(LogLevel.Debug, "HttpConnection.transport is undefined in HttpConnection.stop() because start() failed.");
            _a.label = 10;
          case 10:
            return [2];
        }
      });
    });
  };
  HttpConnection2.prototype.startInternal = function(transferFormat) {
    return __awaiter7(this, void 0, void 0, function() {
      var url, negotiateResponse, redirects, _loop_1, this_1, e_3;
      return __generator7(this, function(_a) {
        switch (_a.label) {
          case 0:
            url = this.baseUrl;
            this.accessTokenFactory = this.options.accessTokenFactory;
            _a.label = 1;
          case 1:
            _a.trys.push([1, 12, , 13]);
            if (!this.options.skipNegotiation)
              return [3, 5];
            if (!(this.options.transport === HttpTransportType.WebSockets))
              return [3, 3];
            this.transport = this.constructTransport(HttpTransportType.WebSockets);
            return [4, this.startTransport(url, transferFormat)];
          case 2:
            _a.sent();
            return [3, 4];
          case 3:
            throw new Error("Negotiation can only be skipped when using the WebSocket transport directly.");
          case 4:
            return [3, 11];
          case 5:
            negotiateResponse = null;
            redirects = 0;
            _loop_1 = function() {
              var accessToken_1;
              return __generator7(this, function(_a2) {
                switch (_a2.label) {
                  case 0:
                    return [4, this_1.getNegotiationResponse(url)];
                  case 1:
                    negotiateResponse = _a2.sent();
                    if (this_1.connectionState === "Disconnecting" || this_1.connectionState === "Disconnected") {
                      throw new Error("The connection was stopped during negotiation.");
                    }
                    if (negotiateResponse.error) {
                      throw new Error(negotiateResponse.error);
                    }
                    if (negotiateResponse.ProtocolVersion) {
                      throw new Error("Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details.");
                    }
                    if (negotiateResponse.url) {
                      url = negotiateResponse.url;
                    }
                    if (negotiateResponse.accessToken) {
                      accessToken_1 = negotiateResponse.accessToken;
                      this_1.accessTokenFactory = function() {
                        return accessToken_1;
                      };
                    }
                    redirects++;
                    return [2];
                }
              });
            };
            this_1 = this;
            _a.label = 6;
          case 6:
            return [5, _loop_1()];
          case 7:
            _a.sent();
            _a.label = 8;
          case 8:
            if (negotiateResponse.url && redirects < MAX_REDIRECTS)
              return [3, 6];
            _a.label = 9;
          case 9:
            if (redirects === MAX_REDIRECTS && negotiateResponse.url) {
              throw new Error("Negotiate redirection limit exceeded.");
            }
            return [4, this.createTransport(url, this.options.transport, negotiateResponse, transferFormat)];
          case 10:
            _a.sent();
            _a.label = 11;
          case 11:
            if (this.transport instanceof LongPollingTransport) {
              this.features.inherentKeepAlive = true;
            }
            if (this.connectionState === "Connecting") {
              this.logger.log(LogLevel.Debug, "The HttpConnection connected successfully.");
              this.connectionState = "Connected";
            }
            return [3, 13];
          case 12:
            e_3 = _a.sent();
            this.logger.log(LogLevel.Error, "Failed to start the connection: " + e_3);
            this.connectionState = "Disconnected";
            this.transport = void 0;
            this.stopPromiseResolver();
            return [2, Promise.reject(e_3)];
          case 13:
            return [2];
        }
      });
    });
  };
  HttpConnection2.prototype.getNegotiationResponse = function(url) {
    return __awaiter7(this, void 0, void 0, function() {
      var headers, token, _a, name, value, negotiateUrl, response, negotiateResponse, e_4;
      return __generator7(this, function(_b) {
        switch (_b.label) {
          case 0:
            headers = {};
            if (!this.accessTokenFactory)
              return [3, 2];
            return [4, this.accessTokenFactory()];
          case 1:
            token = _b.sent();
            if (token) {
              headers["Authorization"] = "Bearer " + token;
            }
            _b.label = 2;
          case 2:
            _a = getUserAgentHeader(), name = _a[0], value = _a[1];
            headers[name] = value;
            negotiateUrl = this.resolveNegotiateUrl(url);
            this.logger.log(LogLevel.Debug, "Sending negotiation request: " + negotiateUrl + ".");
            _b.label = 3;
          case 3:
            _b.trys.push([3, 5, , 6]);
            return [4, this.httpClient.post(negotiateUrl, {
              content: "",
              headers: __assign7({}, headers, this.options.headers),
              withCredentials: this.options.withCredentials
            })];
          case 4:
            response = _b.sent();
            if (response.statusCode !== 200) {
              return [2, Promise.reject(new Error("Unexpected status code returned from negotiate '" + response.statusCode + "'"))];
            }
            negotiateResponse = JSON.parse(response.content);
            if (!negotiateResponse.negotiateVersion || negotiateResponse.negotiateVersion < 1) {
              negotiateResponse.connectionToken = negotiateResponse.connectionId;
            }
            return [2, negotiateResponse];
          case 5:
            e_4 = _b.sent();
            this.logger.log(LogLevel.Error, "Failed to complete negotiation with the server: " + e_4);
            return [2, Promise.reject(e_4)];
          case 6:
            return [2];
        }
      });
    });
  };
  HttpConnection2.prototype.createConnectUrl = function(url, connectionToken) {
    if (!connectionToken) {
      return url;
    }
    return url + (url.indexOf("?") === -1 ? "?" : "&") + ("id=" + connectionToken);
  };
  HttpConnection2.prototype.createTransport = function(url, requestedTransport, negotiateResponse, requestedTransferFormat) {
    return __awaiter7(this, void 0, void 0, function() {
      var connectUrl, transportExceptions, transports, negotiate, _i, transports_1, endpoint, transportOrError, ex_1, ex_2, message;
      return __generator7(this, function(_a) {
        switch (_a.label) {
          case 0:
            connectUrl = this.createConnectUrl(url, negotiateResponse.connectionToken);
            if (!this.isITransport(requestedTransport))
              return [3, 2];
            this.logger.log(LogLevel.Debug, "Connection was provided an instance of ITransport, using that directly.");
            this.transport = requestedTransport;
            return [4, this.startTransport(connectUrl, requestedTransferFormat)];
          case 1:
            _a.sent();
            this.connectionId = negotiateResponse.connectionId;
            return [2];
          case 2:
            transportExceptions = [];
            transports = negotiateResponse.availableTransports || [];
            negotiate = negotiateResponse;
            _i = 0, transports_1 = transports;
            _a.label = 3;
          case 3:
            if (!(_i < transports_1.length))
              return [3, 13];
            endpoint = transports_1[_i];
            transportOrError = this.resolveTransportOrError(endpoint, requestedTransport, requestedTransferFormat);
            if (!(transportOrError instanceof Error))
              return [3, 4];
            transportExceptions.push(endpoint.transport + " failed: " + transportOrError);
            return [3, 12];
          case 4:
            if (!this.isITransport(transportOrError))
              return [3, 12];
            this.transport = transportOrError;
            if (!!negotiate)
              return [3, 9];
            _a.label = 5;
          case 5:
            _a.trys.push([5, 7, , 8]);
            return [4, this.getNegotiationResponse(url)];
          case 6:
            negotiate = _a.sent();
            return [3, 8];
          case 7:
            ex_1 = _a.sent();
            return [2, Promise.reject(ex_1)];
          case 8:
            connectUrl = this.createConnectUrl(url, negotiate.connectionToken);
            _a.label = 9;
          case 9:
            _a.trys.push([9, 11, , 12]);
            return [4, this.startTransport(connectUrl, requestedTransferFormat)];
          case 10:
            _a.sent();
            this.connectionId = negotiate.connectionId;
            return [2];
          case 11:
            ex_2 = _a.sent();
            this.logger.log(LogLevel.Error, "Failed to start the transport '" + endpoint.transport + "': " + ex_2);
            negotiate = void 0;
            transportExceptions.push(endpoint.transport + " failed: " + ex_2);
            if (this.connectionState !== "Connecting") {
              message = "Failed to select transport before stop() was called.";
              this.logger.log(LogLevel.Debug, message);
              return [2, Promise.reject(new Error(message))];
            }
            return [3, 12];
          case 12:
            _i++;
            return [3, 3];
          case 13:
            if (transportExceptions.length > 0) {
              return [2, Promise.reject(new Error("Unable to connect to the server with any of the available transports. " + transportExceptions.join(" ")))];
            }
            return [2, Promise.reject(new Error("None of the transports supported by the client are supported by the server."))];
        }
      });
    });
  };
  HttpConnection2.prototype.constructTransport = function(transport) {
    switch (transport) {
      case HttpTransportType.WebSockets:
        if (!this.options.WebSocket) {
          throw new Error("'WebSocket' is not supported in your environment.");
        }
        return new WebSocketTransport(this.httpClient, this.accessTokenFactory, this.logger, this.options.logMessageContent || false, this.options.WebSocket, this.options.headers || {});
      case HttpTransportType.ServerSentEvents:
        if (!this.options.EventSource) {
          throw new Error("'EventSource' is not supported in your environment.");
        }
        return new ServerSentEventsTransport(this.httpClient, this.accessTokenFactory, this.logger, this.options.logMessageContent || false, this.options.EventSource, this.options.withCredentials, this.options.headers || {});
      case HttpTransportType.LongPolling:
        return new LongPollingTransport(this.httpClient, this.accessTokenFactory, this.logger, this.options.logMessageContent || false, this.options.withCredentials, this.options.headers || {});
      default:
        throw new Error("Unknown transport: " + transport + ".");
    }
  };
  HttpConnection2.prototype.startTransport = function(url, transferFormat) {
    var _this = this;
    this.transport.onreceive = this.onreceive;
    this.transport.onclose = function(e) {
      return _this.stopConnection(e);
    };
    return this.transport.connect(url, transferFormat);
  };
  HttpConnection2.prototype.resolveTransportOrError = function(endpoint, requestedTransport, requestedTransferFormat) {
    var transport = HttpTransportType[endpoint.transport];
    if (transport === null || transport === void 0) {
      this.logger.log(LogLevel.Debug, "Skipping transport '" + endpoint.transport + "' because it is not supported by this client.");
      return new Error("Skipping transport '" + endpoint.transport + "' because it is not supported by this client.");
    } else {
      if (transportMatches(requestedTransport, transport)) {
        var transferFormats = endpoint.transferFormats.map(function(s) {
          return TransferFormat[s];
        });
        if (transferFormats.indexOf(requestedTransferFormat) >= 0) {
          if (transport === HttpTransportType.WebSockets && !this.options.WebSocket || transport === HttpTransportType.ServerSentEvents && !this.options.EventSource) {
            this.logger.log(LogLevel.Debug, "Skipping transport '" + HttpTransportType[transport] + "' because it is not supported in your environment.'");
            return new Error("'" + HttpTransportType[transport] + "' is not supported in your environment.");
          } else {
            this.logger.log(LogLevel.Debug, "Selecting transport '" + HttpTransportType[transport] + "'.");
            try {
              return this.constructTransport(transport);
            } catch (ex) {
              return ex;
            }
          }
        } else {
          this.logger.log(LogLevel.Debug, "Skipping transport '" + HttpTransportType[transport] + "' because it does not support the requested transfer format '" + TransferFormat[requestedTransferFormat] + "'.");
          return new Error("'" + HttpTransportType[transport] + "' does not support " + TransferFormat[requestedTransferFormat] + ".");
        }
      } else {
        this.logger.log(LogLevel.Debug, "Skipping transport '" + HttpTransportType[transport] + "' because it was disabled by the client.");
        return new Error("'" + HttpTransportType[transport] + "' is disabled by the client.");
      }
    }
  };
  HttpConnection2.prototype.isITransport = function(transport) {
    return transport && typeof transport === "object" && "connect" in transport;
  };
  HttpConnection2.prototype.stopConnection = function(error) {
    var _this = this;
    this.logger.log(LogLevel.Debug, "HttpConnection.stopConnection(" + error + ") called while in state " + this.connectionState + ".");
    this.transport = void 0;
    error = this.stopError || error;
    this.stopError = void 0;
    if (this.connectionState === "Disconnected") {
      this.logger.log(LogLevel.Debug, "Call to HttpConnection.stopConnection(" + error + ") was ignored because the connection is already in the disconnected state.");
      return;
    }
    if (this.connectionState === "Connecting") {
      this.logger.log(LogLevel.Warning, "Call to HttpConnection.stopConnection(" + error + ") was ignored because the connection is still in the connecting state.");
      throw new Error("HttpConnection.stopConnection(" + error + ") was called while the connection is still in the connecting state.");
    }
    if (this.connectionState === "Disconnecting") {
      this.stopPromiseResolver();
    }
    if (error) {
      this.logger.log(LogLevel.Error, "Connection disconnected with error '" + error + "'.");
    } else {
      this.logger.log(LogLevel.Information, "Connection disconnected.");
    }
    if (this.sendQueue) {
      this.sendQueue.stop().catch(function(e) {
        _this.logger.log(LogLevel.Error, "TransportSendQueue.stop() threw error '" + e + "'.");
      });
      this.sendQueue = void 0;
    }
    this.connectionId = void 0;
    this.connectionState = "Disconnected";
    if (this.connectionStarted) {
      this.connectionStarted = false;
      try {
        if (this.onclose) {
          this.onclose(error);
        }
      } catch (e) {
        this.logger.log(LogLevel.Error, "HttpConnection.onclose(" + error + ") threw error '" + e + "'.");
      }
    }
  };
  HttpConnection2.prototype.resolveUrl = function(url) {
    if (url.lastIndexOf("https://", 0) === 0 || url.lastIndexOf("http://", 0) === 0) {
      return url;
    }
    if (!Platform.isBrowser || !window.document) {
      throw new Error("Cannot resolve '" + url + "'.");
    }
    var aTag = window.document.createElement("a");
    aTag.href = url;
    this.logger.log(LogLevel.Information, "Normalizing '" + url + "' to '" + aTag.href + "'.");
    return aTag.href;
  };
  HttpConnection2.prototype.resolveNegotiateUrl = function(url) {
    var index = url.indexOf("?");
    var negotiateUrl = url.substring(0, index === -1 ? url.length : index);
    if (negotiateUrl[negotiateUrl.length - 1] !== "/") {
      negotiateUrl += "/";
    }
    negotiateUrl += "negotiate";
    negotiateUrl += index === -1 ? "" : url.substring(index);
    if (negotiateUrl.indexOf("negotiateVersion") === -1) {
      negotiateUrl += index === -1 ? "?" : "&";
      negotiateUrl += "negotiateVersion=" + this.negotiateVersion;
    }
    return negotiateUrl;
  };
  return HttpConnection2;
}();
function transportMatches(requestedTransport, actualTransport) {
  return !requestedTransport || (actualTransport & requestedTransport) !== 0;
}
var TransportSendQueue = function() {
  function TransportSendQueue2(transport) {
    this.transport = transport;
    this.buffer = [];
    this.executing = true;
    this.sendBufferedData = new PromiseSource();
    this.transportResult = new PromiseSource();
    this.sendLoopPromise = this.sendLoop();
  }
  TransportSendQueue2.prototype.send = function(data) {
    this.bufferData(data);
    if (!this.transportResult) {
      this.transportResult = new PromiseSource();
    }
    return this.transportResult.promise;
  };
  TransportSendQueue2.prototype.stop = function() {
    this.executing = false;
    this.sendBufferedData.resolve();
    return this.sendLoopPromise;
  };
  TransportSendQueue2.prototype.bufferData = function(data) {
    if (this.buffer.length && typeof this.buffer[0] !== typeof data) {
      throw new Error("Expected data to be of type " + typeof this.buffer + " but was of type " + typeof data);
    }
    this.buffer.push(data);
    this.sendBufferedData.resolve();
  };
  TransportSendQueue2.prototype.sendLoop = function() {
    return __awaiter7(this, void 0, void 0, function() {
      var transportResult, data, error_1;
      return __generator7(this, function(_a) {
        switch (_a.label) {
          case 0:
            if (false)
              return [3, 6];
            return [4, this.sendBufferedData.promise];
          case 1:
            _a.sent();
            if (!this.executing) {
              if (this.transportResult) {
                this.transportResult.reject("Connection stopped.");
              }
              return [3, 6];
            }
            this.sendBufferedData = new PromiseSource();
            transportResult = this.transportResult;
            this.transportResult = void 0;
            data = typeof this.buffer[0] === "string" ? this.buffer.join("") : TransportSendQueue2.concatBuffers(this.buffer);
            this.buffer.length = 0;
            _a.label = 2;
          case 2:
            _a.trys.push([2, 4, , 5]);
            return [4, this.transport.send(data)];
          case 3:
            _a.sent();
            transportResult.resolve();
            return [3, 5];
          case 4:
            error_1 = _a.sent();
            transportResult.reject(error_1);
            return [3, 5];
          case 5:
            return [3, 0];
          case 6:
            return [2];
        }
      });
    });
  };
  TransportSendQueue2.concatBuffers = function(arrayBuffers) {
    var totalLength = arrayBuffers.map(function(b) {
      return b.byteLength;
    }).reduce(function(a, b) {
      return a + b;
    });
    var result = new Uint8Array(totalLength);
    var offset = 0;
    for (var _i = 0, arrayBuffers_1 = arrayBuffers; _i < arrayBuffers_1.length; _i++) {
      var item = arrayBuffers_1[_i];
      result.set(new Uint8Array(item), offset);
      offset += item.byteLength;
    }
    return result.buffer;
  };
  return TransportSendQueue2;
}();
var PromiseSource = function() {
  function PromiseSource2() {
    var _this = this;
    this.promise = new Promise(function(resolve, reject) {
      var _a;
      return _a = [resolve, reject], _this.resolver = _a[0], _this.rejecter = _a[1], _a;
    });
  }
  PromiseSource2.prototype.resolve = function() {
    this.resolver();
  };
  PromiseSource2.prototype.reject = function(reason) {
    this.rejecter(reason);
  };
  return PromiseSource2;
}();

// node_modules/@microsoft/signalr/dist/esm/JsonHubProtocol.js
var JSON_HUB_PROTOCOL_NAME = "json";
var JsonHubProtocol = function() {
  function JsonHubProtocol2() {
    this.name = JSON_HUB_PROTOCOL_NAME;
    this.version = 1;
    this.transferFormat = TransferFormat.Text;
  }
  JsonHubProtocol2.prototype.parseMessages = function(input, logger) {
    if (typeof input !== "string") {
      throw new Error("Invalid input for JSON hub protocol. Expected a string.");
    }
    if (!input) {
      return [];
    }
    if (logger === null) {
      logger = NullLogger.instance;
    }
    var messages = TextMessageFormat.parse(input);
    var hubMessages = [];
    for (var _i = 0, messages_1 = messages; _i < messages_1.length; _i++) {
      var message = messages_1[_i];
      var parsedMessage = JSON.parse(message);
      if (typeof parsedMessage.type !== "number") {
        throw new Error("Invalid payload.");
      }
      switch (parsedMessage.type) {
        case MessageType.Invocation:
          this.isInvocationMessage(parsedMessage);
          break;
        case MessageType.StreamItem:
          this.isStreamItemMessage(parsedMessage);
          break;
        case MessageType.Completion:
          this.isCompletionMessage(parsedMessage);
          break;
        case MessageType.Ping:
          break;
        case MessageType.Close:
          break;
        default:
          logger.log(LogLevel.Information, "Unknown message type '" + parsedMessage.type + "' ignored.");
          continue;
      }
      hubMessages.push(parsedMessage);
    }
    return hubMessages;
  };
  JsonHubProtocol2.prototype.writeMessage = function(message) {
    return TextMessageFormat.write(JSON.stringify(message));
  };
  JsonHubProtocol2.prototype.isInvocationMessage = function(message) {
    this.assertNotEmptyString(message.target, "Invalid payload for Invocation message.");
    if (message.invocationId !== void 0) {
      this.assertNotEmptyString(message.invocationId, "Invalid payload for Invocation message.");
    }
  };
  JsonHubProtocol2.prototype.isStreamItemMessage = function(message) {
    this.assertNotEmptyString(message.invocationId, "Invalid payload for StreamItem message.");
    if (message.item === void 0) {
      throw new Error("Invalid payload for StreamItem message.");
    }
  };
  JsonHubProtocol2.prototype.isCompletionMessage = function(message) {
    if (message.result && message.error) {
      throw new Error("Invalid payload for Completion message.");
    }
    if (!message.result && message.error) {
      this.assertNotEmptyString(message.error, "Invalid payload for Completion message.");
    }
    this.assertNotEmptyString(message.invocationId, "Invalid payload for Completion message.");
  };
  JsonHubProtocol2.prototype.assertNotEmptyString = function(value, errorMessage) {
    if (typeof value !== "string" || value === "") {
      throw new Error(errorMessage);
    }
  };
  return JsonHubProtocol2;
}();

// node_modules/@microsoft/signalr/dist/esm/HubConnectionBuilder.js
var __assign8 = Object.assign || function(t) {
  for (var s, i = 1, n = arguments.length; i < n; i++) {
    s = arguments[i];
    for (var p in s)
      if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
  }
  return t;
};
var LogLevelNameMapping = {
  trace: LogLevel.Trace,
  debug: LogLevel.Debug,
  info: LogLevel.Information,
  information: LogLevel.Information,
  warn: LogLevel.Warning,
  warning: LogLevel.Warning,
  error: LogLevel.Error,
  critical: LogLevel.Critical,
  none: LogLevel.None
};
function parseLogLevel(name) {
  var mapping = LogLevelNameMapping[name.toLowerCase()];
  if (typeof mapping !== "undefined") {
    return mapping;
  } else {
    throw new Error("Unknown log level: " + name);
  }
}
var HubConnectionBuilder = function() {
  function HubConnectionBuilder2() {
  }
  HubConnectionBuilder2.prototype.configureLogging = function(logging) {
    Arg.isRequired(logging, "logging");
    if (isLogger(logging)) {
      this.logger = logging;
    } else if (typeof logging === "string") {
      var logLevel = parseLogLevel(logging);
      this.logger = new ConsoleLogger(logLevel);
    } else {
      this.logger = new ConsoleLogger(logging);
    }
    return this;
  };
  HubConnectionBuilder2.prototype.withUrl = function(url, transportTypeOrOptions) {
    Arg.isRequired(url, "url");
    Arg.isNotEmpty(url, "url");
    this.url = url;
    if (typeof transportTypeOrOptions === "object") {
      this.httpConnectionOptions = __assign8({}, this.httpConnectionOptions, transportTypeOrOptions);
    } else {
      this.httpConnectionOptions = __assign8({}, this.httpConnectionOptions, { transport: transportTypeOrOptions });
    }
    return this;
  };
  HubConnectionBuilder2.prototype.withHubProtocol = function(protocol) {
    Arg.isRequired(protocol, "protocol");
    this.protocol = protocol;
    return this;
  };
  HubConnectionBuilder2.prototype.withAutomaticReconnect = function(retryDelaysOrReconnectPolicy) {
    if (this.reconnectPolicy) {
      throw new Error("A reconnectPolicy has already been set.");
    }
    if (!retryDelaysOrReconnectPolicy) {
      this.reconnectPolicy = new DefaultReconnectPolicy();
    } else if (Array.isArray(retryDelaysOrReconnectPolicy)) {
      this.reconnectPolicy = new DefaultReconnectPolicy(retryDelaysOrReconnectPolicy);
    } else {
      this.reconnectPolicy = retryDelaysOrReconnectPolicy;
    }
    return this;
  };
  HubConnectionBuilder2.prototype.build = function() {
    var httpConnectionOptions = this.httpConnectionOptions || {};
    if (httpConnectionOptions.logger === void 0) {
      httpConnectionOptions.logger = this.logger;
    }
    if (!this.url) {
      throw new Error("The 'HubConnectionBuilder.withUrl' method must be called before building the connection.");
    }
    var connection = new HttpConnection(this.url, httpConnectionOptions);
    return HubConnection.create(connection, this.logger || NullLogger.instance, this.protocol || new JsonHubProtocol(), this.reconnectPolicy);
  };
  return HubConnectionBuilder2;
}();
function isLogger(logger) {
  return logger.log !== void 0;
}
export {
  AbortError,
  DefaultHttpClient,
  HttpClient,
  HttpError,
  HttpResponse,
  HttpTransportType,
  HubConnection,
  HubConnectionBuilder,
  HubConnectionState,
  JsonHubProtocol,
  LogLevel,
  MessageType,
  NullLogger,
  Subject,
  TimeoutError,
  TransferFormat,
  VERSION
};
//# sourceMappingURL=@microsoft_signalr.js.map
